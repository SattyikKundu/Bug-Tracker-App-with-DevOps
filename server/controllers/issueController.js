// server/controllers/issueController.js

import mongoose from "mongoose";      // For importing functionalities for interacting with MongoDB
import { ObjectId } from "mongodb";    // Import 'ObjectId' reliable array ops

import Issue, 
    { STATUSES, 
      TYPES, 
      PRIORITIES, 
      SEVERITIES } from "../models/issueModel.js"; // imports Issue model + created enums

import Project from "../models/projectModel.js";  // imports Project model
import User from "../models/user.js";             // imports User model
  
const isValidId = (id)=> { // validate id helper function
    mongoose.Types.ObjectId.isValid(id);
}

const userCanEditIssue = (user, project, issue)=>{ // Checks if user is allowed to edit issue for project

  if (!user || !project || !issue) { // end function if any inputs missing
    return false;
  }              
  if(user.role==="admin") { // If user is Admin, grant full access
    return true;                   
  }

  // Check user's other role(s)
  const uid      = String(user._id);                         // Get current user's id
  const isLead   = String(project.leadUserId)===uid;         // Check's if user is project lead
  const isMember = project.members.some(m=>String(m)===uid); // Check is user is a project team member

  // Check is user is a Reporter (One who reports the issue) OR assignee (one who fixes the issue).
  const isReporterOrAssignee = String(issue.reporterId)===uid ||(issue.assigneeId && String(issue.assigneeId)===uid); 
  return isLead || (isMember && isReporterOrAssignee);   // Allowed if user is a lead OR a (member + reporter/assignee)
};

// POST /projects/:pid/issues  (project must be loaded & membership checked in routes)
export const createIssue = async (req,res,next)=>{

  try{

    const { pid } = req.params; // Project id from URL

    if (!isValidId(pid)){ // If invalid project Id, return 400 (error) response
        return res.status(400).json({error:"Invalid project id."});
    }

    const project = req.project || await Project.findById(pid).lean(); // Use loaded project or fetch
    
    if (!project) { // If not project found, return 404 (error) response
        return res.status(404).json({error:"Project not found."}); 
    }

    const {
      title, 
      description="", 
      type="bug", 
      priority="medium", 
      severity="major",
      assigneeId=null, 
      labels=[], 
      watchers=[]
    } = req.body||{};  // Destructure values from request body (which also has default values if not provided)

    if(!title?.trim()) { // return error if title is missing
        return res.status(400).json({error:"title is required."}); 
    } 

    // Validate various enum field values
    if(!TYPES.includes(type)){
        return res.status(400).json({error:"Invalid type."});
    }
    if(!PRIORITIES.includes(priority)){ 
        return res.status(400).json({error:"Invalid priority."});
    }
    if(!SEVERITIES.includes(severity)){ 
        return res.status(400).json({error:"Invalid severity."});
    }

    // Membership gate already done in routes; reporter is current user
    const reporterId = req.authUser._id;                  // Reporter = current user

    // Validate/verify assignee + watchers (if provided)
    const people = [                        // create array of assignee + watchers
      ...(assigneeId ? [assigneeId] : []),  // include assigneeId if present
      ...watchers                           // include all watchers' ids
    ].filter(Boolean)                       // Drop falsy values (null, "", undefined)
    .map(String);                           // Normalize all ids to strings

    for(const id of people){  // validate each users' id in people array
        if(!isValidId(id)) {
            return res.status(400).json({error:`Invalid user id: ${id}`}); 
        }
    } 

    if(people.length){ // Check if 1 or more user ids is missing via checking user id count match
      const found = await User.countDocuments({_id:{ $in: people }}); // get user Id count from database
      if(found!==people.length){ // compare count
        return res.status(400).json({error:"One or more user ids do not exist."});
      }
    }

    // Create 'issue' to pass on (key generated by pre('validate') hook)
    const issue = await Issue.create({
      projectId: pid, // parent project where issue lies
      title, 
      description, 
      type, 
      priority, 
      severity,
      reporterId, // current user Id (one who reported)
      assigneeId: assigneeId || null, // Null = unassigned
      labels,
      watchers: [...new Set(watchers.map(String))]  // De-duplicate watchers via Set(); 
                                                    //  Mongoose casts to ObjectId on save
    });

    return res.status(201).json({issue}); // return success (201) response regarding that 'issue' has passed
  }
  catch(err){ // error handling
    next(err); 
  }
};

// GET /projects/:pid/issues  (project + membership checked in routes)
export const listIssues = async (req,res,next)=>{

  try{
    const { pid } = req.params; // get project id from request params

    if(!isValidId(pid)){  // validate project id
        return res.status(400).json({error:"Invalid project id."});
    }

    const project = req.project || await Project.findById(pid).lean(); // get project object

    if(!project){ // If project is missing...
        return res.status(404).json({error:"Project not found."});
    }

    // Filters (NOTE: 'q' is the free-text search query (i.e. text box search input))
    const { status, priority, assigneeId, q } = req.query; 

    const find = { projectId: pid }; // create Object used to 'find' issues for a specific project

    if(status && STATUSES.includes(status)) { // add 'status' to find
        find.status = status; 
    }
    if(priority && PRIORITIES.includes(priority)){ // add 'priority' to find
        find.priority = priority; 
    }
    if(assigneeId && isValidId(assigneeId)){ // add assigneeId to find
        find.assigneeId = assigneeId; 
    }
    if(q && q.trim()){ // free-text search term
        find.$text = { $search: q.trim() };
    }

    const issues = await Issue.find(find).sort({createdAt:-1}).lean(); // 1st, find issue using 'find' 
    return res.json({issues});                                         // 2nd, .sort({createdAt:-1}) sorts query 
                                                                       // results via 'createdAt' in descending order
                                                                       // 3rd, .lean() returns plain JSONs instead of moongoose objs
  }
  catch(err){ 
    next(err); 
  }
};

// GET /issues/:id  (issue loader sets req.issue + req.project; membership checked in routes)
export const getIssue = async (req,res)=>{ // Retrieve issue
    return res.json({issue:req.issue}); 
}; 

// PATCH /issues/:id  (loader + membership checked, and finer policy enforced here)
export const updateIssue = async (req,res,next)=>{

  try{
    const issue = await Issue.findById(req.issue._id); // Try finding issue via id first

    if(!issue){ // If no issue found....
        return res.status(404).json({error:"Issue not found."});
    }

    const project = req.project;  // get issue's parent project from request
    const user    = req.authUser; // get current user from request

    if(!userCanEditIssue(user,project,issue)){ // Checks is user has permission to edit issue
      return res.status(403).json({error:"Not allowed to edit this issue."});
    }

    const { 
        title, 
        description, 
        type, 
        priority,
        severity, 
        assigneeId, 
        labels, 
        watchers 
    } = req.body||{}; // Destructure inputs from request body

    if(title!==undefined){  // Checks if title is valid
        if(!title?.trim()){
            return res.status(400).json({error:"title cannot be empty."}); issue.title = title;
        }  
    }
    if(description!==undefined){ // Checks is description is valid
        issue.description = String(description);
    }
    if(type!==undefined){  // Checks if issue type is valid
        if(!TYPES.includes(type)) { 
            return res.status(400).json({error:"Invalid type."}); issue.type = type; 
        }
    }

    if(priority!==undefined){  // Checks if priority is valid
        if(!PRIORITIES.includes(priority)){ 
            return res.status(400).json({error:"Invalid priority."}); issue.priority = priority; 
        }
    }
    
    if(severity!==undefined){ // checks if severity is valid 
        if(!SEVERITIES.includes(severity)) {
            return res.status(400).json({error:"Invalid severity."}); issue.severity = severity; 
        }
    }
    
    if(labels!==undefined){ // checks if labels is valid
        if(!Array.isArray(labels)){
            return res.status(400).json({error:"labels must be array."}); issue.labels = labels; 
        } 
    }

    if(watchers!==undefined){  // validate watchers if provided
      if(!Array.isArray(watchers)){
         return res.status(400).json({error:"watchers must be array."});
      }

      const ws = [...new Set(watchers // put watchers into an array of unique ids
        .filter(Boolean)   // 1) remove falsy entries: undefined, null, '', 0, false, NaN
        .map(String)       // 2) normalize every id to a string (e.g., ObjectId -> '64f...abc')
      )];                  // 3) wrap in Set to drop duplicates, then spread back to a plain array

      for(const id of ws){ // checks is each id is valid
        if(!isValidId(id)){ 
            return res.status(400).json({error:`Invalid watcher id: ${id}`}); 
        }
      }
       
      if(ws.length){ // checks if one or more watcher ids don't exists via comparing counts
        const n = await User.countDocuments({_id:{ $in: ws }}); // counts each id in 'ws'
        if(n!==ws.length){  // compares with length of 'ws'
            return res.status(400).json({error:"One or more watcher ids do not exist."});
        } 
      }
      
      issue.watchers = ws.map(id=>ObjectId.createFromHexString(id)); // Store as ObjectId[]
    }

    if(assigneeId!==undefined){ // Validate assignee if provided

      if(assigneeId!==null && !isValidId(assigneeId)) { // If assignee Id invalid...
        return res.status(400).json({error:"Invalid assigneeId."});
      }

      if(assigneeId){ // If assignee Id valid...
        const exists = await User.exists({_id:assigneeId}); 
        if(!exists){
             return res.status(400).json({error:"Assignee does not exist."}); 
        }
      }

      // attach assignedId to issue
      issue.assigneeId = assigneeId ? ObjectId.createFromHexString(String(assigneeId)) : null;
    }

    const saved = await issue.save();     // Saves created 'issue' to MongoDB database to 'issues' collection 
    return res.json({issue:saved.toObject()}); // Return updated object sent to database
  }
  catch(err){ 
    next(err); 
  }
};

// POST /issues/:id/transition (loader + membership checked first, then editing permission policy enforced)
export const transitionStatus = async (req,res,next)=>{

  try{
    const issue = await Issue.findById(req.issue._id); // Return issue document via issue id
    
    if(!issue){ // If no issue found
        return res.status(404).json({error:"Issue not found."}); 
    }
    
    const project = req.project; // extract project and authUser from request body
    const user = req.authUser;      
    
    if(!userCanEditIssue(user,project,issue)){ // Checks if user has editing permission
      return res.status(403).json({error:"Not allowed to transition this issue."});
    }
    
    // Accept both 'to' (official) and 'targetStatus' (alias) from the client
    const { to, targetStatus } = req.body || {};
    const nextStatus = targetStatus ?? to;   // clearer and less ambiguous local name
    
    if(!nextStatus || !STATUSES.includes(nextStatus)){
        return res.status(400).json({error:"Invalid target status."});
    }
    
    if(issue.status===nextStatus){ // No-op
        return res.json({issue:issue.toObject()});
    } 

    const from = issue.status;  // fetch previous status
    issue.status = nextStatus;  // set new status
    issue.statusHistory.push({from, to: nextStatus, by:user._id, at:new Date()}); // save status history for auditing
    issue.closedAt = nextStatus==="closed" ? new Date() : undefined;  // Maintain 'closedAt' (date when issue is closed)

    const saved = await issue.save(); // saved updated 'issue' to 'issues' collection in MongoDB
    return res.json({issue:saved.toObject()}); // Return sent updated 'issue'
  }
  catch(err){  // catch, handle, and pass error in Express pipeline
    next(err); 
  }
};
